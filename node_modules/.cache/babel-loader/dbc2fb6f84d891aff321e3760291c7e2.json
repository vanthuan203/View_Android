{"ast":null,"code":"import { ToRawFixed } from './ToRawFixed';\nimport { digitMapping } from './digit-mapping.generated';\nimport { S_UNICODE_REGEX } from '../regex.generated'; // This is from: unicode-12.1.0/General_Category/Symbol/regex.js\n// IE11 does not support unicode flag, otherwise this is just /\\p{S}/u.\n// /^\\p{S}/u\n\nvar CARET_S_UNICODE_REGEX = new RegExp(\"^\".concat(S_UNICODE_REGEX.source)); // /\\p{S}$/u\n\nvar S_DOLLAR_UNICODE_REGEX = new RegExp(\"\".concat(S_UNICODE_REGEX.source, \"$\"));\nvar CLDR_NUMBER_PATTERN = /[#0](?:[\\.,][#0]+)*/g;\nexport default function formatToParts(numberResult, data, pl, options) {\n  var sign = numberResult.sign,\n      exponent = numberResult.exponent,\n      magnitude = numberResult.magnitude;\n  var notation = options.notation,\n      style = options.style,\n      numberingSystem = options.numberingSystem;\n  var defaultNumberingSystem = data.numbers.nu[0]; // #region Part 1: partition and interpolate the CLDR number pattern.\n  // ----------------------------------------------------------\n\n  var compactNumberPattern = null;\n\n  if (notation === 'compact' && magnitude) {\n    compactNumberPattern = getCompactDisplayPattern(numberResult, pl, data, style, options.compactDisplay, options.currencyDisplay, numberingSystem);\n  } // This is used multiple times\n\n\n  var nonNameCurrencyPart;\n\n  if (style === 'currency' && options.currencyDisplay !== 'name') {\n    var byCurrencyDisplay = data.currencies[options.currency];\n\n    if (byCurrencyDisplay) {\n      switch (options.currencyDisplay) {\n        case 'code':\n          nonNameCurrencyPart = options.currency;\n          break;\n\n        case 'symbol':\n          nonNameCurrencyPart = byCurrencyDisplay.symbol;\n          break;\n\n        default:\n          nonNameCurrencyPart = byCurrencyDisplay.narrow;\n          break;\n      }\n    } else {\n      // Fallback for unknown currency\n      nonNameCurrencyPart = options.currency;\n    }\n  }\n\n  var numberPattern;\n\n  if (!compactNumberPattern) {\n    // Note: if the style is unit, or is currency and the currency display is name,\n    // its unit parts will be interpolated in part 2. So here we can fallback to decimal.\n    if (style === 'decimal' || style === 'unit' || style === 'currency' && options.currencyDisplay === 'name') {\n      // Shortcut for decimal\n      var decimalData = data.numbers.decimal[numberingSystem] || data.numbers.decimal[defaultNumberingSystem];\n      numberPattern = getPatternForSign(decimalData.standard, sign);\n    } else if (style === 'currency') {\n      var currencyData = data.numbers.currency[numberingSystem] || data.numbers.currency[defaultNumberingSystem]; // We replace number pattern part with `0` for easier postprocessing.\n\n      numberPattern = getPatternForSign(currencyData[options.currencySign], sign);\n    } else {\n      // percent\n      var percentPattern = data.numbers.percent[numberingSystem] || data.numbers.percent[defaultNumberingSystem];\n      numberPattern = getPatternForSign(percentPattern, sign);\n    }\n  } else {\n    numberPattern = compactNumberPattern;\n  } // Extract the decimal number pattern string. It looks like \"#,##0,00\", which will later be\n  // used to infer decimal group sizes.\n\n\n  var decimalNumberPattern = CLDR_NUMBER_PATTERN.exec(numberPattern)[0]; // Now we start to substitute patterns\n  // 1. replace strings like `0` and `#,##0.00` with `{0}`\n  // 2. unquote characters (invariant: the quoted characters does not contain the special tokens)\n\n  numberPattern = numberPattern.replace(CLDR_NUMBER_PATTERN, '{0}').replace(/'(.)'/g, '$1'); // Handle currency spacing (both compact and non-compact).\n\n  if (style === 'currency' && options.currencyDisplay !== 'name') {\n    var currencyData = data.numbers.currency[numberingSystem] || data.numbers.currency[defaultNumberingSystem]; // See `currencySpacing` substitution rule in TR-35.\n    // Here we always assume the currencyMatch is \"[:^S:]\" and surroundingMatch is \"[:digit:]\".\n    //\n    // Example 1: for pattern \"#,##0.00¤\" with symbol \"US$\", we replace \"¤\" with the symbol,\n    // but insert an extra non-break space before the symbol, because \"[:^S:]\" matches \"U\" in\n    // \"US$\" and \"[:digit:]\" matches the latn numbering system digits.\n    //\n    // Example 2: for pattern \"¤#,##0.00\" with symbol \"US$\", there is no spacing between symbol\n    // and number, because `$` does not match \"[:^S:]\".\n    //\n    // Implementation note: here we do the best effort to infer the insertion.\n    // We also assume that `beforeInsertBetween` and `afterInsertBetween` will never be `;`.\n\n    var afterCurrency = currencyData.currencySpacing.afterInsertBetween;\n\n    if (afterCurrency && !S_DOLLAR_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n      numberPattern = numberPattern.replace('¤{0}', \"\\xA4\".concat(afterCurrency, \"{0}\"));\n    }\n\n    var beforeCurrency = currencyData.currencySpacing.beforeInsertBetween;\n\n    if (beforeCurrency && !CARET_S_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n      numberPattern = numberPattern.replace('{0}¤', \"{0}\".concat(beforeCurrency, \"\\xA4\"));\n    }\n  } // The following tokens are special: `{0}`, `¤`, `%`, `-`, `+`, `{c:...}.\n\n\n  var numberPatternParts = numberPattern.split(/({c:[^}]+}|\\{0\\}|[¤%\\-\\+])/g);\n  var numberParts = [];\n  var symbols = data.numbers.symbols[numberingSystem] || data.numbers.symbols[defaultNumberingSystem];\n\n  for (var _i = 0, numberPatternParts_1 = numberPatternParts; _i < numberPatternParts_1.length; _i++) {\n    var part = numberPatternParts_1[_i];\n\n    if (!part) {\n      continue;\n    }\n\n    switch (part) {\n      case '{0}':\n        {\n          // We only need to handle scientific and engineering notation here.\n          numberParts.push.apply(numberParts, paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, // If compact number pattern exists, do not insert group separators.\n          !compactNumberPattern && options.useGrouping, decimalNumberPattern));\n          break;\n        }\n\n      case '-':\n        numberParts.push({\n          type: 'minusSign',\n          value: symbols.minusSign\n        });\n        break;\n\n      case '+':\n        numberParts.push({\n          type: 'plusSign',\n          value: symbols.plusSign\n        });\n        break;\n\n      case '%':\n        numberParts.push({\n          type: 'percentSign',\n          value: symbols.percentSign\n        });\n        break;\n\n      case '¤':\n        // Computed above when handling currency spacing.\n        numberParts.push({\n          type: 'currency',\n          value: nonNameCurrencyPart\n        });\n        break;\n\n      default:\n        if (/^\\{c:/.test(part)) {\n          numberParts.push({\n            type: 'compact',\n            value: part.substring(3, part.length - 1)\n          });\n        } else {\n          // literal\n          numberParts.push({\n            type: 'literal',\n            value: part\n          });\n        }\n\n        break;\n    }\n  } // #endregion\n  // #region Part 2: interpolate unit pattern if necessary.\n  // ----------------------------------------------\n\n\n  switch (style) {\n    case 'currency':\n      {\n        // `currencyDisplay: 'name'` has similar pattern handling as units.\n        if (options.currencyDisplay === 'name') {\n          var unitPattern = (data.numbers.currency[numberingSystem] || data.numbers.currency[defaultNumberingSystem]).unitPattern; // Select plural\n\n          var unitName = void 0;\n          var currencyNameData = data.currencies[options.currency];\n\n          if (currencyNameData) {\n            unitName = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), currencyNameData.displayName);\n          } else {\n            // Fallback for unknown currency\n            unitName = options.currency;\n          } // Do {0} and {1} substitution\n\n\n          var unitPatternParts = unitPattern.split(/(\\{[01]\\})/g);\n          var result = [];\n\n          for (var _a = 0, unitPatternParts_1 = unitPatternParts; _a < unitPatternParts_1.length; _a++) {\n            var part = unitPatternParts_1[_a];\n\n            switch (part) {\n              case '{0}':\n                result.push.apply(result, numberParts);\n                break;\n\n              case '{1}':\n                result.push({\n                  type: 'currency',\n                  value: unitName\n                });\n                break;\n\n              default:\n                if (part) {\n                  result.push({\n                    type: 'literal',\n                    value: part\n                  });\n                }\n\n                break;\n            }\n          }\n\n          return result;\n        } else {\n          return numberParts;\n        }\n      }\n\n    case 'unit':\n      {\n        var unit = options.unit,\n            unitDisplay = options.unitDisplay;\n        var unitData = data.units.simple[unit];\n        var unitPattern = void 0;\n\n        if (unitData) {\n          // Simple unit pattern\n          unitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[unit][unitDisplay]);\n        } else {\n          // See: http://unicode.org/reports/tr35/tr35-general.html#perUnitPatterns\n          // If cannot find unit in the simple pattern, it must be \"per\" compound pattern.\n          // Implementation note: we are not following TR-35 here because we need to format to parts!\n          var _b = unit.split('-per-'),\n              numeratorUnit = _b[0],\n              denominatorUnit = _b[1];\n\n          unitData = data.units.simple[numeratorUnit];\n          var numeratorUnitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[numeratorUnit][unitDisplay]);\n          var perUnitPattern = data.units.simple[denominatorUnit].perUnit[unitDisplay];\n\n          if (perUnitPattern) {\n            // perUnitPattern exists, combine it with numeratorUnitPattern\n            unitPattern = perUnitPattern.replace('{0}', numeratorUnitPattern);\n          } else {\n            // get compoundUnit pattern (e.g. \"{0} per {1}\"), repalce {0} with numerator pattern and {1} with\n            // the denominator pattern in singular form.\n            var perPattern = data.units.compound.per[unitDisplay];\n            var denominatorPattern = selectPlural(pl, 1, data.units.simple[denominatorUnit][unitDisplay]);\n            unitPattern = unitPattern = perPattern.replace('{0}', numeratorUnitPattern).replace('{1}', denominatorPattern.replace('{0}', ''));\n          }\n        }\n\n        var result = []; // We need spacing around \"{0}\" because they are not treated as \"unit\" parts, but \"literal\".\n\n        for (var _c = 0, _d = unitPattern.split(/(\\s*\\{0\\}\\s*)/); _c < _d.length; _c++) {\n          var part = _d[_c];\n          var interpolateMatch = /^(\\s*)\\{0\\}(\\s*)$/.exec(part);\n\n          if (interpolateMatch) {\n            // Space before \"{0}\"\n            if (interpolateMatch[1]) {\n              result.push({\n                type: 'literal',\n                value: interpolateMatch[1]\n              });\n            } // \"{0}\" itself\n\n\n            result.push.apply(result, numberParts); // Space after \"{0}\"\n\n            if (interpolateMatch[2]) {\n              result.push({\n                type: 'literal',\n                value: interpolateMatch[2]\n              });\n            }\n          } else if (part) {\n            result.push({\n              type: 'unit',\n              value: part\n            });\n          }\n        }\n\n        return result;\n      }\n\n    default:\n      return numberParts;\n  } // #endregion\n\n} // A subset of https://tc39.es/ecma402/#sec-partitionnotationsubpattern\n// Plus the exponent parts handling.\n\nfunction paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, useGrouping,\n/**\n * This is the decimal number pattern without signs or symbols.\n * It is used to infer the group size when `useGrouping` is true.\n *\n * A typical value looks like \"#,##0.00\" (primary group size is 3).\n * Some locales like Hindi has secondary group size of 2 (e.g. \"#,##,##0.00\").\n */\ndecimalNumberPattern) {\n  var result = []; // eslint-disable-next-line prefer-const\n\n  var n = numberResult.formattedString,\n      x = numberResult.roundedNumber;\n\n  if (isNaN(x)) {\n    return [{\n      type: 'nan',\n      value: n\n    }];\n  } else if (!isFinite(x)) {\n    return [{\n      type: 'infinity',\n      value: n\n    }];\n  }\n\n  var digitReplacementTable = digitMapping[numberingSystem];\n\n  if (digitReplacementTable) {\n    n = n.replace(/\\d/g, function (digit) {\n      return digitReplacementTable[+digit] || digit;\n    });\n  } // TODO: Else use an implementation dependent algorithm to map n to the appropriate\n  // representation of n in the given numbering system.\n\n\n  var decimalSepIndex = n.indexOf('.');\n  var integer;\n  var fraction;\n\n  if (decimalSepIndex > 0) {\n    integer = n.slice(0, decimalSepIndex);\n    fraction = n.slice(decimalSepIndex + 1);\n  } else {\n    integer = n;\n  } // #region Grouping integer digits\n  // The weird compact and x >= 10000 check is to ensure consistency with Node.js and Chrome.\n  // Note that `de` does not have compact form for thousands, but Node.js does not insert grouping separator\n  // unless the rounded number is greater than 10000:\n  //   NumberFormat('de', {notation: 'compact', compactDisplay: 'short'}).format(1234) //=> \"1234\"\n  //   NumberFormat('de').format(1234) //=> \"1.234\"\n\n\n  if (useGrouping && (notation !== 'compact' || x >= 10000)) {\n    var groupSepSymbol = symbols.group;\n    var groups = []; // > There may be two different grouping sizes: The primary grouping size used for the least\n    // > significant integer group, and the secondary grouping size used for more significant groups.\n    // > If a pattern contains multiple grouping separators, the interval between the last one and the\n    // > end of the integer defines the primary grouping size, and the interval between the last two\n    // > defines the secondary grouping size. All others are ignored.\n\n    var integerNumberPattern = decimalNumberPattern.split('.')[0];\n    var patternGroups = integerNumberPattern.split(',');\n    var primaryGroupingSize = 3;\n    var secondaryGroupingSize = 3;\n\n    if (patternGroups.length > 1) {\n      primaryGroupingSize = patternGroups[patternGroups.length - 1].length;\n    }\n\n    if (patternGroups.length > 2) {\n      secondaryGroupingSize = patternGroups[patternGroups.length - 2].length;\n    }\n\n    var i = integer.length - primaryGroupingSize;\n\n    if (i > 0) {\n      // Slice the least significant integer group\n      groups.push(integer.slice(i, i + primaryGroupingSize)); // Then iteratively push the more signicant groups\n      // TODO: handle surrogate pairs in some numbering system digits\n\n      for (i -= secondaryGroupingSize; i > 0; i -= secondaryGroupingSize) {\n        groups.push(integer.slice(i, i + secondaryGroupingSize));\n      }\n\n      groups.push(integer.slice(0, i + secondaryGroupingSize));\n    } else {\n      groups.push(integer);\n    }\n\n    while (groups.length > 0) {\n      var integerGroup = groups.pop();\n      result.push({\n        type: 'integer',\n        value: integerGroup\n      });\n\n      if (groups.length > 0) {\n        result.push({\n          type: 'group',\n          value: groupSepSymbol\n        });\n      }\n    }\n  } else {\n    result.push({\n      type: 'integer',\n      value: integer\n    });\n  } // #endregion\n\n\n  if (fraction !== undefined) {\n    result.push({\n      type: 'decimal',\n      value: symbols.decimal\n    }, {\n      type: 'fraction',\n      value: fraction\n    });\n  }\n\n  if ((notation === 'scientific' || notation === 'engineering') && isFinite(x)) {\n    result.push({\n      type: 'exponentSeparator',\n      value: symbols.exponential\n    });\n\n    if (exponent < 0) {\n      result.push({\n        type: 'exponentMinusSign',\n        value: symbols.minusSign\n      });\n      exponent = -exponent;\n    }\n\n    var exponentResult = ToRawFixed(exponent, 0, 0);\n    result.push({\n      type: 'exponentInteger',\n      value: exponentResult.formattedString\n    });\n  }\n\n  return result;\n}\n\nfunction getPatternForSign(pattern, sign) {\n  if (pattern.indexOf(';') < 0) {\n    pattern = \"\".concat(pattern, \";-\").concat(pattern);\n  }\n\n  var _a = pattern.split(';'),\n      zeroPattern = _a[0],\n      negativePattern = _a[1];\n\n  switch (sign) {\n    case 0:\n      return zeroPattern;\n\n    case -1:\n      return negativePattern;\n\n    default:\n      return negativePattern.indexOf('-') >= 0 ? negativePattern.replace(/-/g, '+') : \"+\".concat(zeroPattern);\n  }\n} // Find the CLDR pattern for compact notation based on the magnitude of data and style.\n//\n// Example return value: \"¤ {c:laki}000;¤{c:laki} -0\" (`sw` locale):\n// - Notice the `{c:...}` token that wraps the compact literal.\n// - The consecutive zeros are normalized to single zero to match CLDR_NUMBER_PATTERN.\n//\n// Returning null means the compact display pattern cannot be found.\n\n\nfunction getCompactDisplayPattern(numberResult, pl, data, style, compactDisplay, currencyDisplay, numberingSystem) {\n  var _a;\n\n  var roundedNumber = numberResult.roundedNumber,\n      sign = numberResult.sign,\n      magnitude = numberResult.magnitude;\n  var magnitudeKey = String(Math.pow(10, magnitude));\n  var defaultNumberingSystem = data.numbers.nu[0];\n  var pattern;\n\n  if (style === 'currency' && currencyDisplay !== 'name') {\n    var byNumberingSystem = data.numbers.currency;\n    var currencyData = byNumberingSystem[numberingSystem] || byNumberingSystem[defaultNumberingSystem]; // NOTE: compact notation ignores currencySign!\n\n    var compactPluralRules = (_a = currencyData.short) === null || _a === void 0 ? void 0 : _a[magnitudeKey];\n\n    if (!compactPluralRules) {\n      return null;\n    }\n\n    pattern = selectPlural(pl, roundedNumber, compactPluralRules);\n  } else {\n    var byNumberingSystem = data.numbers.decimal;\n    var byCompactDisplay = byNumberingSystem[numberingSystem] || byNumberingSystem[defaultNumberingSystem];\n    var compactPlaralRule = byCompactDisplay[compactDisplay][magnitudeKey];\n\n    if (!compactPlaralRule) {\n      return null;\n    }\n\n    pattern = selectPlural(pl, roundedNumber, compactPlaralRule);\n  } // See https://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats\n  // > If the value is precisely “0”, either explicit or defaulted, then the normal number format\n  // > pattern for that sort of object is supplied.\n\n\n  if (pattern === '0') {\n    return null;\n  }\n\n  pattern = getPatternForSign(pattern, sign) // Extract compact literal from the pattern\n  .replace(/([^\\s;\\-\\+\\d¤]+)/g, '{c:$1}') // We replace one or more zeros with a single zero so it matches `CLDR_NUMBER_PATTERN`.\n  .replace(/0+/, '0');\n  return pattern;\n}\n\nfunction selectPlural(pl, x, rules) {\n  return rules[pl.select(x)] || rules.other;\n}","map":{"version":3,"names":["ToRawFixed","digitMapping","S_UNICODE_REGEX","CARET_S_UNICODE_REGEX","RegExp","concat","source","S_DOLLAR_UNICODE_REGEX","CLDR_NUMBER_PATTERN","formatToParts","numberResult","data","pl","options","sign","exponent","magnitude","notation","style","numberingSystem","defaultNumberingSystem","numbers","nu","compactNumberPattern","getCompactDisplayPattern","compactDisplay","currencyDisplay","nonNameCurrencyPart","byCurrencyDisplay","currencies","currency","symbol","narrow","numberPattern","decimalData","decimal","getPatternForSign","standard","currencyData","currencySign","percentPattern","percent","decimalNumberPattern","exec","replace","afterCurrency","currencySpacing","afterInsertBetween","test","beforeCurrency","beforeInsertBetween","numberPatternParts","split","numberParts","symbols","_i","numberPatternParts_1","length","part","push","apply","paritionNumberIntoParts","useGrouping","type","value","minusSign","plusSign","percentSign","substring","unitPattern","unitName","currencyNameData","selectPlural","roundedNumber","Math","pow","displayName","unitPatternParts","result","_a","unitPatternParts_1","unit","unitDisplay","unitData","units","simple","_b","numeratorUnit","denominatorUnit","numeratorUnitPattern","perUnitPattern","perUnit","perPattern","compound","per","denominatorPattern","_c","_d","interpolateMatch","n","formattedString","x","isNaN","isFinite","digitReplacementTable","digit","decimalSepIndex","indexOf","integer","fraction","slice","groupSepSymbol","group","groups","integerNumberPattern","patternGroups","primaryGroupingSize","secondaryGroupingSize","i","integerGroup","pop","undefined","exponential","exponentResult","pattern","zeroPattern","negativePattern","magnitudeKey","String","byNumberingSystem","compactPluralRules","short","byCompactDisplay","compactPlaralRule","rules","select","other"],"sources":["C:/Users/KT2/OneDrive/Documents/Buffh/ssc.fe.cheatview-main/node_modules/@formatjs/intl-relativetimeformat/node_modules/@formatjs/ecma402-abstract/lib/NumberFormat/format_to_parts.js"],"sourcesContent":["import { ToRawFixed } from './ToRawFixed';\nimport { digitMapping } from './digit-mapping.generated';\nimport { S_UNICODE_REGEX } from '../regex.generated';\n// This is from: unicode-12.1.0/General_Category/Symbol/regex.js\n// IE11 does not support unicode flag, otherwise this is just /\\p{S}/u.\n// /^\\p{S}/u\nvar CARET_S_UNICODE_REGEX = new RegExp(\"^\".concat(S_UNICODE_REGEX.source));\n// /\\p{S}$/u\nvar S_DOLLAR_UNICODE_REGEX = new RegExp(\"\".concat(S_UNICODE_REGEX.source, \"$\"));\nvar CLDR_NUMBER_PATTERN = /[#0](?:[\\.,][#0]+)*/g;\nexport default function formatToParts(numberResult, data, pl, options) {\n    var sign = numberResult.sign, exponent = numberResult.exponent, magnitude = numberResult.magnitude;\n    var notation = options.notation, style = options.style, numberingSystem = options.numberingSystem;\n    var defaultNumberingSystem = data.numbers.nu[0];\n    // #region Part 1: partition and interpolate the CLDR number pattern.\n    // ----------------------------------------------------------\n    var compactNumberPattern = null;\n    if (notation === 'compact' && magnitude) {\n        compactNumberPattern = getCompactDisplayPattern(numberResult, pl, data, style, options.compactDisplay, options.currencyDisplay, numberingSystem);\n    }\n    // This is used multiple times\n    var nonNameCurrencyPart;\n    if (style === 'currency' && options.currencyDisplay !== 'name') {\n        var byCurrencyDisplay = data.currencies[options.currency];\n        if (byCurrencyDisplay) {\n            switch (options.currencyDisplay) {\n                case 'code':\n                    nonNameCurrencyPart = options.currency;\n                    break;\n                case 'symbol':\n                    nonNameCurrencyPart = byCurrencyDisplay.symbol;\n                    break;\n                default:\n                    nonNameCurrencyPart = byCurrencyDisplay.narrow;\n                    break;\n            }\n        }\n        else {\n            // Fallback for unknown currency\n            nonNameCurrencyPart = options.currency;\n        }\n    }\n    var numberPattern;\n    if (!compactNumberPattern) {\n        // Note: if the style is unit, or is currency and the currency display is name,\n        // its unit parts will be interpolated in part 2. So here we can fallback to decimal.\n        if (style === 'decimal' ||\n            style === 'unit' ||\n            (style === 'currency' && options.currencyDisplay === 'name')) {\n            // Shortcut for decimal\n            var decimalData = data.numbers.decimal[numberingSystem] ||\n                data.numbers.decimal[defaultNumberingSystem];\n            numberPattern = getPatternForSign(decimalData.standard, sign);\n        }\n        else if (style === 'currency') {\n            var currencyData = data.numbers.currency[numberingSystem] ||\n                data.numbers.currency[defaultNumberingSystem];\n            // We replace number pattern part with `0` for easier postprocessing.\n            numberPattern = getPatternForSign(currencyData[options.currencySign], sign);\n        }\n        else {\n            // percent\n            var percentPattern = data.numbers.percent[numberingSystem] ||\n                data.numbers.percent[defaultNumberingSystem];\n            numberPattern = getPatternForSign(percentPattern, sign);\n        }\n    }\n    else {\n        numberPattern = compactNumberPattern;\n    }\n    // Extract the decimal number pattern string. It looks like \"#,##0,00\", which will later be\n    // used to infer decimal group sizes.\n    var decimalNumberPattern = CLDR_NUMBER_PATTERN.exec(numberPattern)[0];\n    // Now we start to substitute patterns\n    // 1. replace strings like `0` and `#,##0.00` with `{0}`\n    // 2. unquote characters (invariant: the quoted characters does not contain the special tokens)\n    numberPattern = numberPattern\n        .replace(CLDR_NUMBER_PATTERN, '{0}')\n        .replace(/'(.)'/g, '$1');\n    // Handle currency spacing (both compact and non-compact).\n    if (style === 'currency' && options.currencyDisplay !== 'name') {\n        var currencyData = data.numbers.currency[numberingSystem] ||\n            data.numbers.currency[defaultNumberingSystem];\n        // See `currencySpacing` substitution rule in TR-35.\n        // Here we always assume the currencyMatch is \"[:^S:]\" and surroundingMatch is \"[:digit:]\".\n        //\n        // Example 1: for pattern \"#,##0.00¤\" with symbol \"US$\", we replace \"¤\" with the symbol,\n        // but insert an extra non-break space before the symbol, because \"[:^S:]\" matches \"U\" in\n        // \"US$\" and \"[:digit:]\" matches the latn numbering system digits.\n        //\n        // Example 2: for pattern \"¤#,##0.00\" with symbol \"US$\", there is no spacing between symbol\n        // and number, because `$` does not match \"[:^S:]\".\n        //\n        // Implementation note: here we do the best effort to infer the insertion.\n        // We also assume that `beforeInsertBetween` and `afterInsertBetween` will never be `;`.\n        var afterCurrency = currencyData.currencySpacing.afterInsertBetween;\n        if (afterCurrency && !S_DOLLAR_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n            numberPattern = numberPattern.replace('¤{0}', \"\\u00A4\".concat(afterCurrency, \"{0}\"));\n        }\n        var beforeCurrency = currencyData.currencySpacing.beforeInsertBetween;\n        if (beforeCurrency && !CARET_S_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n            numberPattern = numberPattern.replace('{0}¤', \"{0}\".concat(beforeCurrency, \"\\u00A4\"));\n        }\n    }\n    // The following tokens are special: `{0}`, `¤`, `%`, `-`, `+`, `{c:...}.\n    var numberPatternParts = numberPattern.split(/({c:[^}]+}|\\{0\\}|[¤%\\-\\+])/g);\n    var numberParts = [];\n    var symbols = data.numbers.symbols[numberingSystem] ||\n        data.numbers.symbols[defaultNumberingSystem];\n    for (var _i = 0, numberPatternParts_1 = numberPatternParts; _i < numberPatternParts_1.length; _i++) {\n        var part = numberPatternParts_1[_i];\n        if (!part) {\n            continue;\n        }\n        switch (part) {\n            case '{0}': {\n                // We only need to handle scientific and engineering notation here.\n                numberParts.push.apply(numberParts, paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, \n                // If compact number pattern exists, do not insert group separators.\n                !compactNumberPattern && options.useGrouping, decimalNumberPattern));\n                break;\n            }\n            case '-':\n                numberParts.push({ type: 'minusSign', value: symbols.minusSign });\n                break;\n            case '+':\n                numberParts.push({ type: 'plusSign', value: symbols.plusSign });\n                break;\n            case '%':\n                numberParts.push({ type: 'percentSign', value: symbols.percentSign });\n                break;\n            case '¤':\n                // Computed above when handling currency spacing.\n                numberParts.push({ type: 'currency', value: nonNameCurrencyPart });\n                break;\n            default:\n                if (/^\\{c:/.test(part)) {\n                    numberParts.push({\n                        type: 'compact',\n                        value: part.substring(3, part.length - 1),\n                    });\n                }\n                else {\n                    // literal\n                    numberParts.push({ type: 'literal', value: part });\n                }\n                break;\n        }\n    }\n    // #endregion\n    // #region Part 2: interpolate unit pattern if necessary.\n    // ----------------------------------------------\n    switch (style) {\n        case 'currency': {\n            // `currencyDisplay: 'name'` has similar pattern handling as units.\n            if (options.currencyDisplay === 'name') {\n                var unitPattern = (data.numbers.currency[numberingSystem] ||\n                    data.numbers.currency[defaultNumberingSystem]).unitPattern;\n                // Select plural\n                var unitName = void 0;\n                var currencyNameData = data.currencies[options.currency];\n                if (currencyNameData) {\n                    unitName = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), currencyNameData.displayName);\n                }\n                else {\n                    // Fallback for unknown currency\n                    unitName = options.currency;\n                }\n                // Do {0} and {1} substitution\n                var unitPatternParts = unitPattern.split(/(\\{[01]\\})/g);\n                var result = [];\n                for (var _a = 0, unitPatternParts_1 = unitPatternParts; _a < unitPatternParts_1.length; _a++) {\n                    var part = unitPatternParts_1[_a];\n                    switch (part) {\n                        case '{0}':\n                            result.push.apply(result, numberParts);\n                            break;\n                        case '{1}':\n                            result.push({ type: 'currency', value: unitName });\n                            break;\n                        default:\n                            if (part) {\n                                result.push({ type: 'literal', value: part });\n                            }\n                            break;\n                    }\n                }\n                return result;\n            }\n            else {\n                return numberParts;\n            }\n        }\n        case 'unit': {\n            var unit = options.unit, unitDisplay = options.unitDisplay;\n            var unitData = data.units.simple[unit];\n            var unitPattern = void 0;\n            if (unitData) {\n                // Simple unit pattern\n                unitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[unit][unitDisplay]);\n            }\n            else {\n                // See: http://unicode.org/reports/tr35/tr35-general.html#perUnitPatterns\n                // If cannot find unit in the simple pattern, it must be \"per\" compound pattern.\n                // Implementation note: we are not following TR-35 here because we need to format to parts!\n                var _b = unit.split('-per-'), numeratorUnit = _b[0], denominatorUnit = _b[1];\n                unitData = data.units.simple[numeratorUnit];\n                var numeratorUnitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[numeratorUnit][unitDisplay]);\n                var perUnitPattern = data.units.simple[denominatorUnit].perUnit[unitDisplay];\n                if (perUnitPattern) {\n                    // perUnitPattern exists, combine it with numeratorUnitPattern\n                    unitPattern = perUnitPattern.replace('{0}', numeratorUnitPattern);\n                }\n                else {\n                    // get compoundUnit pattern (e.g. \"{0} per {1}\"), repalce {0} with numerator pattern and {1} with\n                    // the denominator pattern in singular form.\n                    var perPattern = data.units.compound.per[unitDisplay];\n                    var denominatorPattern = selectPlural(pl, 1, data.units.simple[denominatorUnit][unitDisplay]);\n                    unitPattern = unitPattern = perPattern\n                        .replace('{0}', numeratorUnitPattern)\n                        .replace('{1}', denominatorPattern.replace('{0}', ''));\n                }\n            }\n            var result = [];\n            // We need spacing around \"{0}\" because they are not treated as \"unit\" parts, but \"literal\".\n            for (var _c = 0, _d = unitPattern.split(/(\\s*\\{0\\}\\s*)/); _c < _d.length; _c++) {\n                var part = _d[_c];\n                var interpolateMatch = /^(\\s*)\\{0\\}(\\s*)$/.exec(part);\n                if (interpolateMatch) {\n                    // Space before \"{0}\"\n                    if (interpolateMatch[1]) {\n                        result.push({ type: 'literal', value: interpolateMatch[1] });\n                    }\n                    // \"{0}\" itself\n                    result.push.apply(result, numberParts);\n                    // Space after \"{0}\"\n                    if (interpolateMatch[2]) {\n                        result.push({ type: 'literal', value: interpolateMatch[2] });\n                    }\n                }\n                else if (part) {\n                    result.push({ type: 'unit', value: part });\n                }\n            }\n            return result;\n        }\n        default:\n            return numberParts;\n    }\n    // #endregion\n}\n// A subset of https://tc39.es/ecma402/#sec-partitionnotationsubpattern\n// Plus the exponent parts handling.\nfunction paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, useGrouping, \n/**\n * This is the decimal number pattern without signs or symbols.\n * It is used to infer the group size when `useGrouping` is true.\n *\n * A typical value looks like \"#,##0.00\" (primary group size is 3).\n * Some locales like Hindi has secondary group size of 2 (e.g. \"#,##,##0.00\").\n */\ndecimalNumberPattern) {\n    var result = [];\n    // eslint-disable-next-line prefer-const\n    var n = numberResult.formattedString, x = numberResult.roundedNumber;\n    if (isNaN(x)) {\n        return [{ type: 'nan', value: n }];\n    }\n    else if (!isFinite(x)) {\n        return [{ type: 'infinity', value: n }];\n    }\n    var digitReplacementTable = digitMapping[numberingSystem];\n    if (digitReplacementTable) {\n        n = n.replace(/\\d/g, function (digit) { return digitReplacementTable[+digit] || digit; });\n    }\n    // TODO: Else use an implementation dependent algorithm to map n to the appropriate\n    // representation of n in the given numbering system.\n    var decimalSepIndex = n.indexOf('.');\n    var integer;\n    var fraction;\n    if (decimalSepIndex > 0) {\n        integer = n.slice(0, decimalSepIndex);\n        fraction = n.slice(decimalSepIndex + 1);\n    }\n    else {\n        integer = n;\n    }\n    // #region Grouping integer digits\n    // The weird compact and x >= 10000 check is to ensure consistency with Node.js and Chrome.\n    // Note that `de` does not have compact form for thousands, but Node.js does not insert grouping separator\n    // unless the rounded number is greater than 10000:\n    //   NumberFormat('de', {notation: 'compact', compactDisplay: 'short'}).format(1234) //=> \"1234\"\n    //   NumberFormat('de').format(1234) //=> \"1.234\"\n    if (useGrouping && (notation !== 'compact' || x >= 10000)) {\n        var groupSepSymbol = symbols.group;\n        var groups = [];\n        // > There may be two different grouping sizes: The primary grouping size used for the least\n        // > significant integer group, and the secondary grouping size used for more significant groups.\n        // > If a pattern contains multiple grouping separators, the interval between the last one and the\n        // > end of the integer defines the primary grouping size, and the interval between the last two\n        // > defines the secondary grouping size. All others are ignored.\n        var integerNumberPattern = decimalNumberPattern.split('.')[0];\n        var patternGroups = integerNumberPattern.split(',');\n        var primaryGroupingSize = 3;\n        var secondaryGroupingSize = 3;\n        if (patternGroups.length > 1) {\n            primaryGroupingSize = patternGroups[patternGroups.length - 1].length;\n        }\n        if (patternGroups.length > 2) {\n            secondaryGroupingSize = patternGroups[patternGroups.length - 2].length;\n        }\n        var i = integer.length - primaryGroupingSize;\n        if (i > 0) {\n            // Slice the least significant integer group\n            groups.push(integer.slice(i, i + primaryGroupingSize));\n            // Then iteratively push the more signicant groups\n            // TODO: handle surrogate pairs in some numbering system digits\n            for (i -= secondaryGroupingSize; i > 0; i -= secondaryGroupingSize) {\n                groups.push(integer.slice(i, i + secondaryGroupingSize));\n            }\n            groups.push(integer.slice(0, i + secondaryGroupingSize));\n        }\n        else {\n            groups.push(integer);\n        }\n        while (groups.length > 0) {\n            var integerGroup = groups.pop();\n            result.push({ type: 'integer', value: integerGroup });\n            if (groups.length > 0) {\n                result.push({ type: 'group', value: groupSepSymbol });\n            }\n        }\n    }\n    else {\n        result.push({ type: 'integer', value: integer });\n    }\n    // #endregion\n    if (fraction !== undefined) {\n        result.push({ type: 'decimal', value: symbols.decimal }, { type: 'fraction', value: fraction });\n    }\n    if ((notation === 'scientific' || notation === 'engineering') &&\n        isFinite(x)) {\n        result.push({ type: 'exponentSeparator', value: symbols.exponential });\n        if (exponent < 0) {\n            result.push({ type: 'exponentMinusSign', value: symbols.minusSign });\n            exponent = -exponent;\n        }\n        var exponentResult = ToRawFixed(exponent, 0, 0);\n        result.push({\n            type: 'exponentInteger',\n            value: exponentResult.formattedString,\n        });\n    }\n    return result;\n}\nfunction getPatternForSign(pattern, sign) {\n    if (pattern.indexOf(';') < 0) {\n        pattern = \"\".concat(pattern, \";-\").concat(pattern);\n    }\n    var _a = pattern.split(';'), zeroPattern = _a[0], negativePattern = _a[1];\n    switch (sign) {\n        case 0:\n            return zeroPattern;\n        case -1:\n            return negativePattern;\n        default:\n            return negativePattern.indexOf('-') >= 0\n                ? negativePattern.replace(/-/g, '+')\n                : \"+\".concat(zeroPattern);\n    }\n}\n// Find the CLDR pattern for compact notation based on the magnitude of data and style.\n//\n// Example return value: \"¤ {c:laki}000;¤{c:laki} -0\" (`sw` locale):\n// - Notice the `{c:...}` token that wraps the compact literal.\n// - The consecutive zeros are normalized to single zero to match CLDR_NUMBER_PATTERN.\n//\n// Returning null means the compact display pattern cannot be found.\nfunction getCompactDisplayPattern(numberResult, pl, data, style, compactDisplay, currencyDisplay, numberingSystem) {\n    var _a;\n    var roundedNumber = numberResult.roundedNumber, sign = numberResult.sign, magnitude = numberResult.magnitude;\n    var magnitudeKey = String(Math.pow(10, magnitude));\n    var defaultNumberingSystem = data.numbers.nu[0];\n    var pattern;\n    if (style === 'currency' && currencyDisplay !== 'name') {\n        var byNumberingSystem = data.numbers.currency;\n        var currencyData = byNumberingSystem[numberingSystem] ||\n            byNumberingSystem[defaultNumberingSystem];\n        // NOTE: compact notation ignores currencySign!\n        var compactPluralRules = (_a = currencyData.short) === null || _a === void 0 ? void 0 : _a[magnitudeKey];\n        if (!compactPluralRules) {\n            return null;\n        }\n        pattern = selectPlural(pl, roundedNumber, compactPluralRules);\n    }\n    else {\n        var byNumberingSystem = data.numbers.decimal;\n        var byCompactDisplay = byNumberingSystem[numberingSystem] ||\n            byNumberingSystem[defaultNumberingSystem];\n        var compactPlaralRule = byCompactDisplay[compactDisplay][magnitudeKey];\n        if (!compactPlaralRule) {\n            return null;\n        }\n        pattern = selectPlural(pl, roundedNumber, compactPlaralRule);\n    }\n    // See https://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats\n    // > If the value is precisely “0”, either explicit or defaulted, then the normal number format\n    // > pattern for that sort of object is supplied.\n    if (pattern === '0') {\n        return null;\n    }\n    pattern = getPatternForSign(pattern, sign)\n        // Extract compact literal from the pattern\n        .replace(/([^\\s;\\-\\+\\d¤]+)/g, '{c:$1}')\n        // We replace one or more zeros with a single zero so it matches `CLDR_NUMBER_PATTERN`.\n        .replace(/0+/, '0');\n    return pattern;\n}\nfunction selectPlural(pl, x, rules) {\n    return rules[pl.select(x)] || rules.other;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}